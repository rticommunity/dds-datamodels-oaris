#ifndef SUBSYSTEM_CONTROLDEFVAR
#define SUBSYSTEM_CONTROLDEFVAR
#include "Common_Types.idl"


// Version 1.1
module org {


  module omg {


    module c4i {


      module Domain_Model {


        module Subsystem_Domain {


          module Subsystem_Control {



            // If the boolean is true the battle override is applied.
            struct battle_override_state_type
            {
            	// Indicates if the battle override is applied or not.
            	boolean battle_override_applied;
            };
  




            // A string type
            typedef string<128> descriptor_parameter_name_string_type;
  




            // A string type
            typedef string<32> descriptor_parameter_type_string_type;
  




            // A string type
            typedef string<32> descriptor_parameter_unit_string_type;
  




            // A string type
            typedef string<32> descriptor_typical_value_string_type;
  




            // a simple union type, to represent an optional value
            union descriptor_typical_value_type switch (boolean)
            {
            	// the value when present
            	case TRUE : org::omg::c4i::Domain_Model::Subsystem_Domain::Subsystem_Control::descriptor_typical_value_string_type value;
            };
  




            // A string type
            typedef string<32> descriptor_parameter_range_string_type;
  




            // a simple union type, to represent an optional value
            union descriptor_parameter_range_type switch (boolean)
            {
            	// the value when present
            	case TRUE : org::omg::c4i::Domain_Model::Subsystem_Domain::Subsystem_Control::descriptor_parameter_range_string_type value;
            };
  




            // Type which is used to indicate a technical state.
            enum technical_state_type
            {
            	// BIT
            	BIT,
            	// CALIBRATE
            	CALIBRATE,
            	// DORMANT
            	DORMANT,
            	// FAILED
            	FAILED,
            	// OFFLINE
            	OFFLINE,
            	// ONLINE
            	ONLINE,
            	// READY
            	READY,
            	// STANDBY
            	STANDBY
            };
  




            // A sequence type, to represent multiple values. Note: unbounded sequence
            typedef sequence<technical_state_type> descriptor_technical_state_type;
  




            // The value should be mapped to the corresponding operational mode. This mapping
            // is retrieved through the service 'Manage Subsystem Parameters'.
            typedef unsigned short operational_mode_type;
  




            // A sequence type, to represent multiple values. Note: unbounded sequence
            typedef sequence<operational_mode_type> descriptor_applicable_operational_mode_type;
  




            // A sequence type, to represent multiple values. Note: variable length sequence.
            typedef sequence<long> descriptor_related_parameter_id_type;
  




            // Type for parameter descriptors. 
            struct descriptor
            {
            	// parameter_name values are unique within the scope of a subsystem.
            	descriptor_parameter_name_string_type parameter_name;
            	descriptor_parameter_type_string_type parameter_type;
            	descriptor_parameter_unit_string_type parameter_unit;
            	// *optional*
            	descriptor_typical_value_type typical_value;
            	// *optional*
            	descriptor_parameter_range_type parameter_range;
            	// Technical state(s) in which this parameter may be modified.
            	descriptor_technical_state_type technical_state;
            	descriptor_applicable_operational_mode_type applicable_operational_mode;
            	// Refers (by index) into the descriptor_sequence instance of which this instance
            	// of the descriptor class is a part.
            	descriptor_related_parameter_id_type related_parameter_id;
            };
  




            // A sequence type, to represent multiple values. Note: variable length sequence.
            typedef sequence<descriptor> descriptor_sequence_element_type;
  




            // Sequence of parameter descriptors, used in retrieving parameter descriptors.
            struct descriptor_sequence
            {
            	descriptor_sequence_element_type element;
            };
  




            // Name of an entry in the device identification.
            typedef string<64> device_name_type;
  




            // Version of the equipment
            struct version_type
            {
            	// Major version number
            	unsigned short major_version;
            	// Minor version number
            	unsigned short minor_version;
            };
  




            // Identification data of the equipment.
            struct device_identification_type
            {
            	// Name of the product. Example TRS3D
            	device_name_type product;
            	// Serial number identifying the individual device. 
            	device_name_type serial_number;
            	// This describes the general type of the equipment. Example: Air Surveillance
            	// Radar
            	device_name_type equipment_type;
            	// Version of the device.
            	version_type version;
            };
  




            // Type of event
            enum event_type
            {
            	// OCCURRENCE
            	OCCURRENCE,
            	// DISAPPEARANCE
            	DISAPPEARANCE
            };
  




            // A string type
            typedef string<32> fault_fault_name_string_type;
  




            // A string type
            typedef string<32> fault_fault_isolation_data_string_type;
  




            // Class to represent a subsystem fault
            struct fault
            {
            	fault_fault_name_string_type fault_name;
            	event_type event;
            	// Indicates whether this fault is real or simulated/inserted.
            	boolean simulated;
            	// Indicates whether this fault is overridden by Battle Override when determining
            	// the health state.
            	boolean overridden;
            	// For instance cabinet id and rack id.
            	fault_fault_isolation_data_string_type fault_isolation_data;
            };
  




            // A sequence type, to represent multiple values. Note: variable length sequence.
            typedef sequence<fault> fault_list_element_type;
  




            // A list of faults
            struct fault_list
            {
            	fault_list_element_type element;
            };
  




            // Reason for the health state
            struct health_state_reason_type
            {
            	boolean caused_by_fault;
            	boolean caused_by_technical_state;
            	boolean caused_by_simulation_mode;
            	boolean caused_by_operational_mode;
            };
  




            // Encapsulation of health state
            enum health_state_type
            {
            	// AVAILABLE
            	AVAILABLE,
            	// DEGRADED
            	DEGRADED,
            	// NOT_AVAILABLE
            	NOT_AVAILABLE,
            	// UNKNOWN
            	UNKNOWN
            };
  




            // Name of information
            enum information_name_type
            {
            	// AIR_PLOTS
            	AIR_PLOTS,
            	// SURFACE_PLOTS
            	SURFACE_PLOTS,
            	// LAND_PLOTS
            	LAND_PLOTS,
            	// SPACE_PLOTS
            	SPACE_PLOTS,
            	// SENSOR_AIR_TRACKS
            	SENSOR_AIR_TRACKS,
            	// SENSOR_SURFACE_TRACKS
            	SENSOR_SURFACE_TRACKS,
            	// SENSOR_LAND_TRACKS
            	SENSOR_LAND_TRACKS,
            	// SENSOR_SPACE_TRACKS
            	SENSOR_SPACE_TRACKS,
            	// JAMMER_STROBES
            	JAMMER_STROBES,
            	// JAMMER_TRACKS
            	JAMMER_TRACKS,
            	// JAMMING_EFFECT_ASSESSMENTS
            	JAMMING_EFFECT_ASSESSMENTS,
            	// INTERFERENCE_REPORTS
            	INTERFERENCE_REPORTS
            };
  




            // A string type
            typedef string<32> interest_quality_of_service_string_type;
  




            // A string type
            typedef string<32> interest_recipient_string_type;
  




            // Type of registration
            enum registration_type
            {
            	// REGISTER
            	REGISTER,
            	// DEREGISTER
            	DEREGISTER
            };
  




            // Encapsulation of interest in service
            struct interest
            {
            	registration_type registration;
            	// * optional *
            	interest_quality_of_service_string_type quality_of_service;
            	// * optional *
            	interest_recipient_string_type recipient;
            };
  




            // A sequence type, to represent multiple values. Note: variable length sequence,
            // which should contain at least one instance.
            typedef sequence<interest> interest_list_element_type;
  




            // A list of interest
            struct interest_list
            {
            	interest_list_element_type element;
            };
  




            // This enumeration represents the state of the mastership.
            //    The subsystem Mastership may be either “free”, that is assigned to none and
            // then available to anybody asks for it, or assigned to somebody: CMS or not.
            enum mastership_state_type
            {
            	// Mastership state is “free”, the first received Mastership request shall be
            	// satisfied.
            	MASTERSHIP_FREE,
            	// The Mastership is assigned to somebody other than CMS.
            	MASTERSHIP_OTHER,
            	// The Mastership is assigned to CMS.
            	MASTERSHIP_TO_CMS
            };
  




            // A string type
            typedef string<32> name_error_pair_error_indication_string_type;
  




            // A string type
            typedef string<128> name_error_pair_parameter_name_string_type;
  




            // Combination of name of parameter (for which a request could not be processed)
            // and an indication of the error.
            struct name_error_pair_type
            {
            	// parameter_name values are unique within the scope of a subsystem.
            	name_error_pair_parameter_name_string_type parameter_name;
            	name_error_pair_error_indication_string_type error_indication;
            };
  




            // A sequence type, to represent multiple values. Note: variable length sequence.
            typedef sequence<name_error_pair_type> name_error_sequence_element_type;
  




            // sequence of error reports identifying the parameter names for which the request
            // could not be processed, including an indication of the error (e.g. unknown
            // parameter, illegal value).
            struct name_error_sequence_type
            {
            	name_error_sequence_element_type element;
            };
  




            // A string type
            typedef string<128> name_value_pair_parameter_name_string_type;
  




            // A string type
            typedef string<32> name_value_pair_value_string_type;
  




            // A generic struct for (name, value) pairs. Used in multiple situations. 
            struct name_value_pair_type
            {
            	// parameter_name values are unique within the scope of a subsystem.
            	name_value_pair_parameter_name_string_type parameter_name;
            	name_value_pair_value_string_type value;
            };
  




            // A sequence type, to represent multiple values. Note: variable length sequence.
            typedef sequence<name_value_pair_type> name_value_sequence_element_type;
  




            // Sequence of (name, value) pairs used in retrieving and modifying parameters. 
            struct name_value_sequence_type
            {
            	name_value_sequence_element_type element;
            };
  




            // A string type
            typedef string<128> parameter_name_parameter_name_string_type;
  




            // Typedef for strings representing names of parameters. 
            struct parameter_name_type
            {
            	// parameter_name values are unique within the scope of a subsystem.
            	parameter_name_parameter_name_string_type parameter_name;
            };
  




            // A sequence type, to represent multiple values. Note: variable length sequence.
            typedef sequence<parameter_name_type> parameter_name_sequence_element_type;
  




            // A sequence of strings (names). Used in request for parameters and parameter
            // descriptors. If the sequence is empty, the request is for all parameters. 
            struct parameter_name_sequence_type
            {
            	parameter_name_sequence_element_type element;
            };
  




            // Response type for retrieving and modifying sequences of parameters.
            struct parameter_value_response_type
            {
            	long request_id;
            };
  




            // Enumeration of possible service names. Where a service may be offered at
            // different compliance levels, multiple names are introduced with _LEVEL_x
            // postfix to indicate different parts. 
            enum service_name_type
            {
            	// AIR_ENGAGEMENT_SUPPORT
            	AIR_ENGAGEMENT_SUPPORT,
            	// CLUTTER_REPORTING
            	CLUTTER_REPORTING,
            	// ENCYCLOPAEDIC_SUPPORT
            	ENCYCLOPAEDIC_SUPPORT,
            	// ENGAGEMENT_SUPPORT
            	ENGAGEMENT_SUPPORT,
            	// ENVIRONMENT_AND_STABILIZATION_LEVEL_3F
            	ENVIRONMENT_AND_STABILIZATION_LEVEL_3F,
            	// ENVIRONMENT_AND_STABILIZATION_LEVEL_3G
            	ENVIRONMENT_AND_STABILIZATION_LEVEL_3G,
            	// EXTENDED_SUBSYSTEM_CONTROL
            	EXTENDED_SUBSYSTEM_CONTROL,
            	// JAMMER_REPORTING
            	JAMMER_REPORTING,
            	// MISSILE_GUIDANCE
            	MISSILE_GUIDANCE,
            	// PLOT_REPORTING_LEVEL_1
            	PLOT_REPORTING_LEVEL_1,
            	// PLOT_REPORTING_LEVEL_3C
            	PLOT_REPORTING_LEVEL_3C,
            	// PLOT_REPORTING_LEVEL_3E
            	PLOT_REPORTING_LEVEL_3E,
            	// RECORDING_AND_REPLAY
            	RECORDING_AND_REPLAY,
            	// SEARCH
            	SEARCH,
            	// SENSOR_CONTROL_LEVEL_2
            	SENSOR_CONTROL_LEVEL_2,
            	// SENSOR_PERFORMANCE
            	SENSOR_PERFORMANCE,
            	// SIMULATION_SUPPORT
            	SIMULATION_SUPPORT,
            	// SUBSYSTEM_CONTROL_LEVEL_1
            	SUBSYSTEM_CONTROL_LEVEL_1,
            	// SUBSYSTEM_CONTROL_LEVEL_2
            	SUBSYSTEM_CONTROL_LEVEL_2,
            	// SURFACE_ENGAGEMENT_SUPPORT
            	SURFACE_ENGAGEMENT_SUPPORT,
            	// TRACK_REPORTING_LEVEL_1
            	TRACK_REPORTING_LEVEL_1,
            	// TRACK_REPORTING_LEVEL_3C
            	TRACK_REPORTING_LEVEL_3C,
            	// TRACK_REPORTING_LEVEL_3E
            	TRACK_REPORTING_LEVEL_3E,
            	// TRACKING_CONTROL_LEVEL_2
            	TRACKING_CONTROL_LEVEL_2,
            	// TRACKING_CONTROL_LEVEL_3C
            	TRACKING_CONTROL_LEVEL_3C,
            	// SENSOR_CONTROL_LEVEL_3A
            	SENSOR_CONTROL_LEVEL_3A
            };
  




            // Health of service
            struct service_health_type
            {
            	service_name_type service_name;
            	health_state_type health_state;
            	health_state_reason_type health_state_reason;
            	org::omg::c4i::Domain_Model::Common_Types::time_type time_of_information;
            };
  




            // Indication of a service provided by the subsystem.
            struct service_indication_type
            {
            	// Name of the service.
            	service_name_type service_name;
            	// Indication whether the service is registered.
            	boolean registration_indicator;
            };
  




            // A sequence type, to represent multiple values. Note: variable length sequence.
            typedef sequence<service_indication_type> service_indication_list_service_indication_type;
  




            // A list of service indications as used by Provide_Subsystem_Services.
            struct service_indication_list_type
            {
            	service_indication_list_service_indication_type service_indication;
            };
  




            // Information about a service
            struct service_information
            {
            	information_name_type information_name;
            };
  




            // A sequence type, to represent multiple values. Note: variable length sequence.
            typedef sequence<service_name_type> service_list_service_indication_type;
  




            // A list of service names as used by Provide_Subsystem_Services.
            struct service_list_type
            {
            	service_list_service_indication_type service_indication;
            };
  




            // Type of service
            struct service_type
            {
            	// Only registrable services are allowed
            	service_name_type service_name;
            };
  




            // Type describing the health state of a subsystem
            struct subsystem_health_type
            {
            	// Current health state
            	health_state_type health_state;
            	// Reason for last change of health state
            	health_state_reason_type health_state_reason;
            	device_identification_type subsystem_identification;
            	org::omg::c4i::Domain_Model::Common_Types::time_type time_of_information;
            };
  



          };
        };
      };
    };
  };
};
#endif